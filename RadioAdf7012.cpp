/* pecan copyright (C) 2012  KT5TK
 *
 * This program is free software; you can redistribute it and/or
 * modify it under the terms of the GNU General Public License
 * as published by the Free Software Foundation; either version 2
 * of the License, or (at your option) any later version.
 *
 * This program is distributed in the hope that it will be useful,
 * but WITHOUT ANY WARRANTY; without even the implied warranty of
 * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
 * GNU General Public License for more details.
 *
 * You should have received a copy of the GNU General Public License
 * along with this program; if not, write to the Free Software
 * Foundation, Inc., 51 Franklin Street, Fifth Floor, Boston, MA  02110-1301, USA.
 */


#include <RadioAdf7012.h>

#include <M10Configuration.h>

#include <math.h>

const int MAX_RES = 16;
char res_adf7012[MAX_RES];
unsigned int powerlevel;

// Configuration storage structs =============================================
struct {
    struct {
        unsigned int  frequency_error_correction;
        unsigned char r_divider;
        unsigned char crystal_doubler;
        unsigned char crystal_oscillator_disable;
        unsigned char clock_out_divider;
        unsigned char vco_adjust;
        unsigned char output_divider;
    } r0;

    struct {
        unsigned int  fractional_n;
        unsigned char integer_n;
        unsigned char prescaler;
    } r1;

    struct {
        unsigned char mod_control;
        unsigned char gook;
        unsigned char power_amplifier_level;
        unsigned int  modulation_deviation;
        unsigned char gfsk_modulation_control;
        unsigned char index_counter;
    } r2;

    struct {
        unsigned char pll_enable;
        unsigned char pa_enable;
        unsigned char clkout_enable;
        unsigned char data_invert;
        unsigned char charge_pump_current;
        unsigned char bleed_up;
        unsigned char bleed_down;
        unsigned char vco_disable;
        unsigned char muxout;
        unsigned char ld_precision;
        unsigned char vco_bias;
        unsigned char pa_bias;
        unsigned char pll_test_mode;
        unsigned char sd_test_mode;
    } r3;
} adf_config;



// Configuration functions ===================================================

// Config resetting functions --------------------------------------------
void RadioAdf7012::adf_reset_config(void)
{

    adf_reset_register_zero();
    adf_reset_register_one();
    adf_reset_register_two();
    adf_reset_register_three();

    adf_reset();

    //    while(!adf_reg_ready());
}

// Power up default settings are defined here:

void RadioAdf7012::adf_reset_register_zero(void) {
    adf_config.r0.frequency_error_correction = 430;               // Don't bother for now...
    adf_config.r0.r_divider = 4;          // Whatever works best for 2m, 1.25m and 70 cm ham bands
    adf_config.r0.crystal_doubler = 0;                          // Who would want that? Lower f_pfd means finer channel steps.
    adf_config.r0.crystal_oscillator_disable = 1;               // Disable internal crystal oscillator because we have an external VCXO
    adf_config.r0.clock_out_divider = 2;                        // Don't bother for now...
    adf_config.r0.vco_adjust = 1;                               // Don't bother for now... (Will be automatically adjusted until PLL lock is achieved)
    adf_config.r0.output_divider = ADF_OUTPUT_DIVIDER_BY_4;     // Pre-set div 4 for 2m. Will be changed according tx frequency on the fly
}

void RadioAdf7012::adf_reset_register_one(void) {
    adf_config.r1.integer_n = 111;                              // Pre-set for 144.390 MHz APRS. Will be changed according tx frequency on the fly
    adf_config.r1.fractional_n = 1687;                          // Pre-set for 144.390 MHz APRS. Will be changed according tx frequency on the fly
    adf_config.r1.prescaler = ADF_PRESCALER_8_9;                // 8/9 requires an integer_n > 91; 4/5 only requires integer_n > 31
}

void RadioAdf7012::adf_reset_register_two(void) {
    adf_config.r2.mod_control = ADF_MODULATION_FSK;             // For AFSK the modulation is done through the external VCXO we don't want any FM generated by the ADF7012 itself
    adf_config.r2.gook = 0;                                     // Whatever... This might give us a nicer swing in phase maybe...
    adf_config.r2.power_amplifier_level = 16;                   // 16 is about half maximum power. Output -20dBm at 0x0, and 13 dBm at 0x7E at 868 MHz

    adf_config.r2.modulation_deviation = 4;                     // FSK : deviation as a multiple of Fpfd/2^14, with Fpfd = Fxtal/R
    adf_config.r2.gfsk_modulation_control = 0;                  // Don't bother for now...
    adf_config.r2.index_counter = 0;                            // Don't bother for now...
}

void RadioAdf7012::adf_reset_register_three(void) {
    adf_config.r3.pll_enable = 0;                               // Switch off PLL (will be switched on after Ureg is checked and confirmed ok)
    adf_config.r3.pa_enable = 0;                                // Switch off PA  (will be switched on when PLL lock is confirmed)
    adf_config.r3.clkout_enable = 0;                            // No clock output needed at the moment
    adf_config.r3.data_invert = 1;                              // Results in a TX signal when TXDATA input is low
    adf_config.r3.charge_pump_current = ADF_CP_CURRENT_2_1;     // 2.1 mA. This is the maximum
    adf_config.r3.bleed_up = 0;                                 // Don't worry, be happy...
    adf_config.r3.bleed_down = 0;                               // Dito
    adf_config.r3.vco_disable = 0;                              // VCO is on

    adf_config.r3.muxout = ADF_MUXOUT_LOGIC_LOW;                // Set muxout to low (as it is pulled low in the M10)

    adf_config.r3.ld_precision = ADF_LD_PRECISION_3_CYCLES;     // What the heck? It is recommended that LDP be set to 1; 0 is more relaxed
    adf_config.r3.vco_bias = 5;                                 // In 0.5 mA steps; Default 6 means 3 mA; Maximum (15) is 8 mA
    adf_config.r3.pa_bias = 4;                                  // In 1 mA steps; Default 4 means 8 mA; Minimum (0) is 5 mA; Maximum (7) is 12 mA (Datasheet says uA which is bullshit)
    adf_config.r3.pll_test_mode = 0;
    adf_config.r3.sd_test_mode = 0;
}

void RadioAdf7012::adf_reset(void) {
    digitalWrite(M10::ADFLE,   M10::HIGH);
    digitalWrite(M10::ADFTxData, M10::HIGH);
    digitalWrite(M10::ADFClock,  M10::HIGH);
    digitalWrite(M10::ADFData, M10::HIGH);

    M10::delay(100);
}


// Configuration writing functions ---------------------------------------
void RadioAdf7012::adf_write_config(void) {
    adf_write_register_zero();
    adf_write_register_one();
    adf_write_register_two();
    adf_write_register_three();
}

void RadioAdf7012::adf_write_register_zero(void) {

    unsigned long reg =
            (0) |
            ((unsigned long)(adf_config.r0.frequency_error_correction & 0x7FF) << 2U) |
            ((unsigned long)(adf_config.r0.r_divider & 0xF ) << 13U) |
            ((unsigned long)(adf_config.r0.crystal_doubler & 0x1 ) << 17U) |
            ((unsigned long)(adf_config.r0.crystal_oscillator_disable & 0x1 ) << 18U) |
            ((unsigned long)(adf_config.r0.clock_out_divider & 0xF ) << 19U) |
            ((unsigned long)(adf_config.r0.vco_adjust & 0x3 ) << 23U) |
            ((unsigned long)(adf_config.r0.output_divider & 0x3 ) << 25U);

    adf_write_register(reg);
}

void RadioAdf7012::adf_write_register_one(void) {
    unsigned long reg =
            (1) |
            ((unsigned long)(adf_config.r1.fractional_n & 0xFFF) << 2) |
            ((unsigned long)(adf_config.r1.integer_n & 0xFF ) << 14) |
            ((unsigned long)(adf_config.r1.prescaler & 0x1 ) << 22);

    adf_write_register(reg);
}

void RadioAdf7012::adf_write_register_two(void) {
    unsigned long reg =
            (2) |
            ((unsigned long)(adf_config.r2.mod_control & 0x3 ) << 2) |
            ((unsigned long)(adf_config.r2.gook & 0x1 ) << 4) |
            ((unsigned long)(adf_config.r2.power_amplifier_level & 0x3F ) << 5) |
            ((unsigned long)(adf_config.r2.modulation_deviation & 0x1FF) << 11) |
            ((unsigned long)(adf_config.r2.gfsk_modulation_control & 0x7 ) << 20) |
            ((unsigned long)(adf_config.r2.index_counter & 0x3 ) << 23);

    adf_write_register(reg);
}

void RadioAdf7012::adf_write_register_three(void) {
    unsigned long reg =
            (3) |
            ((unsigned long)(adf_config.r3.pll_enable & 0x1 ) << 2) |
            ((unsigned long)(adf_config.r3.pa_enable & 0x1 ) << 3) |
            ((unsigned long)(adf_config.r3.clkout_enable & 0x1 ) << 4) |
            ((unsigned long)(adf_config.r3.data_invert & 0x1 ) << 5) |
            ((unsigned long)(adf_config.r3.charge_pump_current & 0x3 ) << 6) |
            ((unsigned long)(adf_config.r3.bleed_up & 0x1 ) << 8) |
            ((unsigned long)(adf_config.r3.bleed_down & 0x1 ) << 9) |
            ((unsigned long)(adf_config.r3.vco_disable & 0x1 ) << 10) |
            ((unsigned long)(adf_config.r3.muxout & 0xF ) << 11) |
            ((unsigned long)(adf_config.r3.ld_precision & 0x1 ) << 15) |
            ((unsigned long)(adf_config.r3.vco_bias & 0xF ) << 16) |
            ((unsigned long)(adf_config.r3.pa_bias & 0x7 ) << 20) |
            ((unsigned long)(adf_config.r3.pll_test_mode & 0x1F ) << 23) |
            ((unsigned long)(adf_config.r3.sd_test_mode & 0xF ) << 28);

    adf_write_register(reg);
}

void RadioAdf7012::adf_write_register(unsigned long data)
{
    digitalWrite(M10::ADFLE,   M10::HIGH);
    digitalWrite(M10::ADFTxData, M10::HIGH);
    digitalWrite(M10::ADFClock,  M10::HIGH);
    digitalWrite(M10::ADFData, M10::HIGH);

    // Bit bang SPI to ADF7012
    int i;
    digitalWrite(M10::ADFClock, M10::LOW );
    M10::delayMicroseconds(2);
    digitalWrite(M10::ADFLE, M10::LOW);
    M10::delayMicroseconds(10);

    for(i=31; i>=0; i--) {
        if((data & (unsigned long)(1UL<<i))>>i)
        {
            digitalWrite(M10::ADFData, M10::HIGH);
        }
        else
        {
            digitalWrite(M10::ADFData, M10::LOW);
        }
        M10::delayMicroseconds(2);
        digitalWrite(M10::ADFClock, M10::HIGH);
        M10::delayMicroseconds(10);
        digitalWrite(M10::ADFClock,  M10::LOW );
        M10::delayMicroseconds(10);
    }

    M10::delayMicroseconds(2);
    digitalWrite(M10::ADFLE, M10::HIGH);
}


void RadioAdf7012::setup()
{
    pinMode(M10::ADFClock,  M10::OUTPUT);
    pinMode(M10::ADFLE,     M10::OUTPUT);
    pinMode(M10::ADFData,   M10::OUTPUT);
    pinMode(M10::ADFTxData, M10::OUTPUT);

    pinMode(M10::PA,  M10::OUTPUT);
    digitalWrite(M10::PA, M10::LOW);

    adf_reset_config();

    // Center frequency at 438.510MHz
    // Formula : f_pfd = f_crystal / r_divider
    // f_tx = f_pfd * ( integer_n + fractional_n / 4086 )
    adf_config.r0.output_divider = ADF_OUTPUT_DIVIDER_BY_2 ;
    adf_config.r0.r_divider = 4 ;
    adf_config.r1.integer_n = 219 ;
    adf_config.r1.fractional_n = 1050 ;

    adf_config.r3.pll_enable = 1;
    // Between 0 and 3
    adf_config.r0.vco_adjust = 0;
    // Between 0 and 14
    adf_config.r3.vco_bias = 0;

    adf_write_config();
    digitalWrite(M10::ADFTxData, M10::LOW);
    M10::delay(100);
}

void RadioAdf7012::ptt_on()
{
    digitalWrite(M10::PA, M10::HIGH);
    digitalWrite(M10::ADFTxData, M10::LOW);
    adf_config.r3.pa_enable = 0;
    adf_config.r2.power_amplifier_level = 0;

    adf_write_config();
    M10::delay(100);

    // Lock should happen during wait time, then turn on PA
    adf_config.r3.pa_enable = 1;
    adf_config.r2.power_amplifier_level = 50 ; //63 is max power

    adf_write_config();
    M10::delay(50);
    // Now ready to TX
}

void RadioAdf7012::ptt_off()
{
    digitalWrite(M10::PA, M10::LOW);
    adf_config.r3.pa_enable = 0;
    adf_config.r2.power_amplifier_level = 0;
    adf_write_config();
    M10::delay(100);

    digitalWrite(M10::ADFTxData, M10::LOW);
}

void RadioAdf7012::send_data( unsigned char data[], unsigned int size )
{
    // Turn on pa in tx chip
    ptt_on() ;

    for ( unsigned int i = 0 ; i < size ; ++i )
    {
        for ( unsigned int j = 0 ; j < 8 ; ++ j )
        {
            // 1200 baud
            M10::digitalWrite( M10::ADFTxData, ( ( data[i] >> j ) & 0x1 ) ? M10::LOW : M10::HIGH ) ;
            __delay_cycles(6666) ;
        }
    }

    // Turn off pa
    ptt_off() ;
}

